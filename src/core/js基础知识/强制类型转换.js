// 数学运算符中的类型转换----------------------------------------------------------------------------------------------
// 减、乘、除：我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型。
1 - true // 0， 首先把 true 转换为数字 1， 然后执行 1 - 1
1 - null // 1,  首先把 null 转换为数字 0， 然后执行 1 - 0
1 * undefined //  NaN, undefined 转换为数字是 NaN
2 * ['5'] //  10， ['5']首先会变成 '5', 然后再变成数字 5

// 加法的特殊性：JS里 + 除了运算，还可以用来拼接字符串，有3条规则，优先级从高到低：
// （1）当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型
// （2）当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。
// （3）当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。
123 + '123' // 123123   （规则1）
123 + null  // 123    （规则2）
123 + true // 124    （规则2）
123 + {}  // 123[object Object]    （规则3）



// 逻辑语句中的类型转换---------------------------------------------------------------------------------------------------
// 当我们使用 if while for 语句时，我们期望表达式是一个Boolean，所以一定伴随着隐式类型转换。而这里面又分为两种情况：
// 1、单个变量：只有 null undefined '' NaN 0 false 这几个是 false，其他的情况都是 true，比如 {} , []。
// 2、使用 == 比较：有5条规则如下：
// （1）NaN和其他任何类型比较永远返回false（包括和他自己）
// （2）Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。
// （3）String和Number比较，先将String转换为Number类型
// （4）null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false
// （5）原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型（⭐️ToPrimitive规则，是引用类型向原始类型转变的规则，它遵循先valueOf后toString的模式期望得到一个原始类型，如果还是没法得到一个原始类型，就会抛出 TypeError）。
'[object Object]' == {} // true, 对象和字符串比较，对象通过 toString 得到一个基本类型值
'1,2,3' == [1, 2, 3] // true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值

// 特别的题目
// - 第一步，![] 会变成 false
// - 第二步，应用 规则2 ，题目变成： [] == 0
// - 第三步，应用 规则5 ，[]的valueOf是0，题目变成： 0 == 0
// - 所以， 答案是 true ！
[] == ![] //true

// - 第一步，应用 规则5 ，[undefined]通过toString变成 '',
// 题目变成  '' == false
// - 第二步，应用 规则2 ，题目变成  '' == 0
// - 第三步，应用 规则3 ，题目变成  0 == 0
// - 所以， 答案是 true ！
// 但是 if([undefined]) 又是个true！
[undefined] == false // true